#!/usr/bin/env bash
set -euo pipefail

# Gandalf Observability - Healthcheck (silent OK, ntfy on failure)
# Uses /etc/gandalf/backup.env (optional) for shared config + thresholds + OBS_UNITS

ENV_FILE="/etc/gandalf/backup.env"
if [[ -r "$ENV_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$ENV_FILE" || true
fi

# thresholds (env overridable)
DISK_WARN_PCT="${DISK_WARN_PCT:-85}"
DISK_CRIT_PCT="${DISK_CRIT_PCT:-92}"
LOAD_WARN="${LOAD_WARN:-3.0}"
LOAD_CRIT="${LOAD_CRIT:-6.0}"
OK_WINDOW="${OK_WINDOW:-36 hours ago}"

# ntfy (only on failure)
NTFY_URL="${NTFY_URL:-https://ntfy.sh}"
NTFY_TOPIC="${NTFY_TOPIC:-}"
NTFY_TOKEN="${NTFY_TOKEN:-}"
NTFY_PREFIX="${NTFY_PREFIX:-}"

# Extra always-on services/timers to check (space-separated via env)
# Example: OBS_UNITS="eldmark-bot.service pihole-FTL.service unbound.service gandalf-devices-panel.service"
OBS_UNITS="${OBS_UNITS:-}"

ts(){ date "+%Y-%m-%d %H:%M:%S %Z"; }
log(){ echo "[$(ts)] $*"; }
fail(){ echo "FAIL: $*" >&2; return 1; }

ntfy_fail() {
  local text="$*"
  [[ -n "${NTFY_TOPIC:-}" ]] || return 0
  command -v curl >/dev/null 2>&1 || return 0
  local url="${NTFY_URL%/}/${NTFY_TOPIC}"
  local auth=()
  [[ -n "${NTFY_TOKEN:-}" ]] && auth=(-H "Authorization: Bearer ${NTFY_TOKEN}")
  curl -fsS "${auth[@]}" \
    -H "Title: Gandalf" \
    -H "Priority: 5" \
    -H "Tags: pulse,warning" \
    -H "X-Deduplication-Id: gandalf-healthcheck-fail" \
    --data "${NTFY_PREFIX} Healthcheck FAIL: ${text}" \
    "$url" >/dev/null || true
}

disk_pct() { df -P "$1" | awk "NR==2{gsub(\"%\",\"\",\$5); print \$5}"; }
load_1m() { awk "{print \$1}" /proc/loadavg; }
is_float_ge() { awk -v a="$1" -v b="$2" "BEGIN{exit !(a+0 >= b+0)}"; }

last_ok_by_tag() {
  local tag="$1"
  local pattern="$2"
  local since="${3:-36 hours ago}"
  journalctl -t "$tag" --since "$since" -o cat --no-pager 2>/dev/null \
    | tac \
    | grep -m1 -E "$pattern" \
    || true
}

timer_sane() {
  local t="$1"
  local active next
  active="$(systemctl show -p ActiveState --value "$t" 2>/dev/null || echo unknown)"
  [[ "$active" == "active" ]] || fail "$t inactive (ActiveState=$active)"
  next="$(systemctl show -p NextElapseUSecRealtime --value "$t" 2>/dev/null || true)"
  [[ -n "${next:-}" ]] || fail "$t missing NextElapseUSecRealtime (schedule broken?)"
}

unit_active_or_activating() {
  local u="$1"
  local st
  st="$(systemctl is-active "$u" 2>/dev/null || echo unknown)"
  [[ "$st" =~ ^(active|activating)$ ]] || fail "$u not active (is-active=$st)"
}

main() {
  local errors=()

  # If backup is currently running/starting: skip "no BACKUP OK" signal to avoid noisy alerts
  local bstate
  bstate="$(systemctl is-active gandalf-backup.service 2>/dev/null || echo unknown)"
  local backup_in_flight=0
  [[ "$bstate" =~ ^(active|activating)$ ]] && backup_in_flight=1

  # Disk checks
  for mnt in / /var; do
    if [[ "$mnt" == "/var" ]] && ! mountpoint -q /var; then
      continue
    fi
    local pct
    pct="$(disk_pct "$mnt" 2>/dev/null || echo 0)"
    if [[ "$pct" =~ ^[0-9]+$ ]]; then
      if (( pct >= DISK_CRIT_PCT )); then
        errors+=("disk $mnt critical ${pct}% (>=${DISK_CRIT_PCT}%)")
      elif (( pct >= DISK_WARN_PCT )); then
        errors+=("disk $mnt warning ${pct}% (>=${DISK_WARN_PCT}%)")
      fi
    else
      errors+=("disk $mnt pct parse error")
    fi
  done

  # Load checks
  local l1
  l1="$(load_1m 2>/dev/null || echo 0.0)"
  if is_float_ge "$l1" "$LOAD_CRIT"; then
    errors+=("load critical ${l1} (>=${LOAD_CRIT})")
  elif is_float_ge "$l1" "$LOAD_WARN"; then
    errors+=("load warning ${l1} (>=${LOAD_WARN})")
  fi

  # Timers sanity
  timer_sane "gandalf-backup.timer" || errors+=("backup timer not sane")
  timer_sane "gandalf-backup-cleanup.timer" || errors+=("cleanup timer not sane")

  # Last OK signals via journald tags (skip backup-ok check while backup is in-flight)
  local last_backup last_cleanup
  if (( backup_in_flight == 0 )); then
    last_backup="$(last_ok_by_tag "gandalf-backup" "BACKUP: OK|Backup OK" "$OK_WINDOW")"
    [[ -n "${last_backup:-}" ]] || errors+=("no BACKUP OK in tag gandalf-backup since: ${OK_WINDOW}")
  fi
  last_cleanup="$(last_ok_by_tag "gandalf-backup-cleanup" "CLEANUP: ok" "$OK_WINDOW")"
  [[ -n "${last_cleanup:-}" ]] || errors+=("no CLEANUP ok in tag gandalf-backup-cleanup since: ${OK_WINDOW}")

  # Side services/timers (best effort)
  if [[ -n "$OBS_UNITS" ]]; then
    for u in $OBS_UNITS; do
      if [[ "$u" == *.timer ]]; then
        timer_sane "$u" || errors+=("$u timer not sane")
      else
        unit_active_or_activating "$u" || errors+=("$u not active")
      fi
    done
  fi

  if (( ${#errors[@]} > 0 )); then
    local msg
    msg="$(printf "%s; " "${errors[@]}")"
    log "HEALTHCHECK: FAIL ${msg}"
    ntfy_fail "${msg}"
    exit 1
  fi

  exit 0
}

main "$@"
